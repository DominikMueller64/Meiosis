---
title: "Meiosis: A package for simulating meiosis events."
author: "Dominik Mueller"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction
This vignette describes how to use the R-package Meiosis for simulating meiosis
events in diploid individuals. In general an individual is a list containing two
gametes. A gamete is itself a list of chromosomes. There are two representations
of chromosomes. In the first, "genotypic" representation, a chromosome is
basically an integer vector containing identifiers for alleles. In the
bi-allelic case, this can be 0 and 1, representing a gene content of one of the
alleles. The other representation, is called "segmental" and is described in
Cheng et al. (2015)^[[XSim](https://doi.org/10.1534/g3.115.016683)]. Here, a
chromosome is itself a list with two components. The first is a integer vector
containing identifiers of founder alleles, and the second is a "numeric" vector
(a vector of doubles) that contains positions. The rational is to only track the
(founder) origin of chromosomal segments and their borders. To obtain genotypic
data from the segmental representation, knowledge on (i) the genetic positions
of loci and (ii) the genotypes of founder individuals are needed. The rational
behind the segmental representation is that it can be more efficient that the
genotypic representation in terms of computer memory (it is more efficient to
save only data on segments rather than on all allelic states on these segments)
and computation time for meiosis (it can be more efficient to update the segment
data rather than copying a (possibly very large) number of integers (allelic
states) to build a new gamete. However, converting the segmental representation
to a genotypic representation also takes time. Hence, if genotypes are needed
after each meiosis event, we recommend to used the genotypic representation. If
intermediate genotypes are not needed, for instance when simulating the
production of inbred lines by recurrent selfing, the segmental representation is
likely superior. The segmental representation has, as another advantage, the
possibility to compute realized coefficients of co-ancestry that deviate from
expected coefficients of co-ancestry due to mendelian sampling. For both the
genotypic and the segmental representation, data for simulating crossover events
needs to be provided. Simulating meiosis events according to these two different
types of representations will in the following be illustrated by means of
several examples.

## Examples
The C++ routines use an independent random number generator. For seeding it, do e.g.
```{r}
library('Meiosis')
set.seed(123L)
Meiosis::seed_rng(seed = 123L)
```

### Create crossover parameters
For (internally) simulating crossover events, the functions that are used to simulate meiosis
events accept a special list as paramter. This special list is created by the function
`create_xoparam`, which accepts as obligatory parameter a vector that contains the lengths
of the chromosomes. Below, we randomly sample the lengths of three chromosomes and create the
list containing the crossover parameters. See the documentation of `create_xoparam` for further
parameters.

```{r}
n_chr <- 3L  ## number of chromosomes
L <- runif(n = n_chr, min = 100, max = 300)  ## sample length of chromosomes in cM
xoparam <- create_xoparam(L)  ## no interference, no obligate chiasma
str(xoparam)
```

### Number of loci per chromosome and positions.
For the examples below, we need to simulate some genomic data. We now sample the the number of
loci per chromosome as well as the positions of these loci on the respective chromosome.

```{r}
n_loci <- round(runif(n = n_chr, min = 5L, max = 10L))  ## sample number of loci per chromosome
## sample positions of loci on the chromosome
positions <- lapply(seq_len(n_chr), function(i) sort(runif(n_loci[i], min = 0, max = L[i])))
```

#### Example 1: Simulate meiosis with genotypes.
We here show how to simulate meiosis with data in the "genotypic" representation. We first
simulate some genotypic data of an individual and then call the function `cross_geno` for
simulating meiosis. In this case, the output is a selfing progenty of `ind`.

```{r}
ind <- replicate(2L, lapply(n_loci, function(n) sample(c(0L, 1L), n, replace = TRUE)),
                 simplify = FALSE) ## simulate some genotypic data
str(ind)

p_geno <- Meiosis::cross_geno(father = ind, mother = ind, positions = positions,
                              xoparam = xoparam)
str(p_geno)
```

### Example 2: Simulate meiosis with segmental representation.
We now show how to do the same as in Example 1 with data in the segmental
representation. Here, we first have to create one or multiple founder
individuals. Each founder individual has two (distinct!) founder alleles. These
founder allels are represented by arbitrary but unique integers. Think about
these founder allels as simple tags that are attached to chromosomal segments.
As these segments are "dropped down" the pedigree and sometimes altered by a
recombination event, the tags always guarantee that each chunk of the genome can
be unambiguously assigned to one of the founder indivdiuals. A founder
individual is created with the function `create_xo_founder`, which accepts as
parameters the integer labels and a vector that specifies the length of each
chromosome in cM. A selfing is then simulated by a call to `cross_xo`.

Because data in the "segmental" representation are not useful for many purposes,
we usually will convert them (back) to the "genotypic" representation. To do so,
we first have to create a `Converter` object. This is a special data structures
(reference class) which has two methods: `insert_founder` and `convert`. Before
starting with the conversion, it is necessary to tell the `Converter` object the
genotypes of the founder individuals. This is done via the method
`insert_founder`. The genotypic data of each founder individual that was
involved in the generation of progenty has to be added with a call to this
method, otherwise an error will be thrown later.

```{r}
f_alleles <- c(21L, 65L) ## 21 and 65 are arbitrary integers
f <- Meiosis::create_xo_founder(alleles = f_alleles, L = L)

p_xo <- Meiosis::cross_xo(father = f, mother = f, xoparam = xoparam)
str(p_xo)
```

#### Create a converter for converting segmental data to genotypic data.
```{r}
conv <- new(Meiosis::Converter, positions) ## create a new converter object
conv$insert_founder(f_alleles, ind) ## insert the (one and only) founder
str(conv$convert(p_xo)) ## convert the progeny
```

### Example 3: Derive n inbred lines from a bi-parental cross.
In this example, we show how the derive a number of inbred lines from a cross between two
parents. The first part of the examples shows how to achieve this using the "genotypic"
representation and the second part shows the "segmental" case.

```{r}
n_self <- 10L  ## number of generations of selfing
n <- 30L ## number of progeny

## Genotypic representation
ind2 <- replicate(2L, lapply(n_loci, function(n) sample(c(0L, 1L), n, replace = TRUE)),
                  simplify = FALSE) # Second individual as parent.

pop <- replicate(n, Meiosis::cross_geno(ind, ind2, positions, xoparam), simplify = FALSE)
for (i in seq_len(n_self))
  for (j in seq_len(n))
    pop[[i]] <- Meiosis::cross_geno(pop[[i]], pop[[i]], positions, xoparam)

## Segmental representation
f2 <- create_xo_founder(alleles = c(55L, 77L), L = L)
pop_xo <- replicate(n, Meiosis::cross_xo(f, f2, xoparam), simplify = FALSE)
for (i in seq_len(n_self))
  for (j in seq_len(n))
    pop_xo[[i]] <- Meiosis::cross_xo(pop_xo[[i]], pop_xo[[i]], xoparam)

# conv$convert(pop[[1]]) ## error, because genotypic data of second founder not present
conv$insert_founder(c(55L, 77L), ind2)  ## insert second founder first
pop_geno <- lapply(pop_xo, conv$convert) ## convert whole population
```

### Further examples
We can also produce a doubled haploid progeny, both from the "segmental" and the "genotypic"
representation.

```{r}
## Simulate a doubled haploid individual.
str(Meiosis::dh_geno(ind, positions, xoparam))
str(conv$convert(Meiosis::dh_xo(f, xoparam)))
```

Furthermore, we can calculate realized coefficient of co-ancestry, analogous to the classical
co-ancestry coefficients but taking into account variation due to Mendelian sampling.
```{r}
## Calculate realized coefficients of co-ancestry.
Meiosis::realized_coancestry(f)
Meiosis::realized_coancestry(p_xo) ## selfing progeny, expected coefficient is 0.75.
Meiosis::realized_coancestry(pop_xo[[1L]], pop_xo[[2L]]) ## realized co-ancestry of two full-sibs.
```
