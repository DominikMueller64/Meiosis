// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/Meiosis.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// calc_Lstar
double calc_Lstar(double L, int m, double p, double epsilon);
static SEXP Meiosis_calc_Lstar_try(SEXP LSEXP, SEXP mSEXP, SEXP pSEXP, SEXP epsilonSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double >::type L(LSEXP);
    Rcpp::traits::input_parameter< int >::type m(mSEXP);
    Rcpp::traits::input_parameter< double >::type p(pSEXP);
    Rcpp::traits::input_parameter< double >::type epsilon(epsilonSEXP);
    rcpp_result_gen = Rcpp::wrap(calc_Lstar(L, m, p, epsilon));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP Meiosis_calc_Lstar(SEXP LSEXP, SEXP mSEXP, SEXP pSEXP, SEXP epsilonSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(Meiosis_calc_Lstar_try(LSEXP, mSEXP, pSEXP, epsilonSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// crossover
std::vector<double> crossover(const double L, const int m, const double p, const bool obligate_chiasma, const double Lstar);
static SEXP Meiosis_crossover_try(SEXP LSEXP, SEXP mSEXP, SEXP pSEXP, SEXP obligate_chiasmaSEXP, SEXP LstarSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const double >::type L(LSEXP);
    Rcpp::traits::input_parameter< const int >::type m(mSEXP);
    Rcpp::traits::input_parameter< const double >::type p(pSEXP);
    Rcpp::traits::input_parameter< const bool >::type obligate_chiasma(obligate_chiasmaSEXP);
    Rcpp::traits::input_parameter< const double >::type Lstar(LstarSEXP);
    rcpp_result_gen = Rcpp::wrap(crossover(L, m, p, obligate_chiasma, Lstar));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP Meiosis_crossover(SEXP LSEXP, SEXP mSEXP, SEXP pSEXP, SEXP obligate_chiasmaSEXP, SEXP LstarSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(Meiosis_crossover_try(LSEXP, mSEXP, pSEXP, obligate_chiasmaSEXP, LstarSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// meiosis_xodat_R
Rcpp::List meiosis_xodat_R(const Rcpp::IntegerVector& patalle, const Rcpp::NumericVector& patloc, const Rcpp::IntegerVector& matalle, const Rcpp::NumericVector& matloc, const Rcpp::NumericVector& xlocations);
static SEXP Meiosis_meiosis_xodat_R_try(SEXP patalleSEXP, SEXP patlocSEXP, SEXP matalleSEXP, SEXP matlocSEXP, SEXP xlocationsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const Rcpp::IntegerVector& >::type patalle(patalleSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type patloc(patlocSEXP);
    Rcpp::traits::input_parameter< const Rcpp::IntegerVector& >::type matalle(matalleSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type matloc(matlocSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type xlocations(xlocationsSEXP);
    rcpp_result_gen = Rcpp::wrap(meiosis_xodat_R(patalle, patloc, matalle, matloc, xlocations));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP Meiosis_meiosis_xodat_R(SEXP patalleSEXP, SEXP patlocSEXP, SEXP matalleSEXP, SEXP matlocSEXP, SEXP xlocationsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(Meiosis_meiosis_xodat_R_try(patalleSEXP, patlocSEXP, matalleSEXP, matlocSEXP, xlocationsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int Meiosis_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("double(*calc_Lstar)(double,int,double,double)");
        signatures.insert("std::vector<double>(*crossover)(const double,const int,const double,const bool,const double)");
        signatures.insert("Rcpp::List(*meiosis_xodat)(const Rcpp::IntegerVector&,const Rcpp::NumericVector&,const Rcpp::IntegerVector&,const Rcpp::NumericVector&,const Rcpp::NumericVector&)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP Meiosis_RcppExport_registerCCallable() { 
    R_RegisterCCallable("Meiosis", "Meiosis_calc_Lstar", (DL_FUNC)Meiosis_calc_Lstar_try);
    R_RegisterCCallable("Meiosis", "Meiosis_crossover", (DL_FUNC)Meiosis_crossover_try);
    R_RegisterCCallable("Meiosis", "Meiosis_meiosis_xodat", (DL_FUNC)Meiosis_meiosis_xodat_R_try);
    R_RegisterCCallable("Meiosis", "Meiosis_RcppExport_validate", (DL_FUNC)Meiosis_RcppExport_validate);
    return R_NilValue;
}
